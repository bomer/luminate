
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>

		<script>

var scene, camera, renderer;
var geometry, material1,material2, mesh;
var inactiveBlocks;// = []; //16 wide by 10 height as on PSP
var player = {};
var width=16;
var height=10;
var debugtext;
var dropspeed=15;
var dropcounter=0;


var keys = []; //Key Binding
window.onkeyup = function(e) {keys[e.keyCode]=false; player.movelock=false; player.spinlock=false;}
window.onkeydown = function(e) {keys[e.keyCode]=true; console.log('key down ' + e.keyCode);}

init();
animate();

function init() {

	//player.init
	player.blocksize=window.innerWidth / width;
	player.lockcount=0,player.spincount=0;
	//Camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 1000;
    //Offset from 00 being center
    camera.position.x = width/2 * player.blocksize ;
    camera.position.y = height/2 * player.blocksize ;
    // camera.position.z = 1000;

    var scale=0.95;
    geometry = new THREE.BoxGeometry( player.blocksize*scale, player.blocksize*scale,player.blocksize*scale);
    material1 = new THREE.MeshPhongMaterial( { color: 0xff0000, wireframe: false } );
    material2 = new THREE.MeshPhongMaterial( { color: 0xffffff, wireframe: false } );

    
    // player.y=2;
    //Empty blocks
    inactiveBlocks = new THREE.Object3D();

    //setup player block 
    player.group = new THREE.Object3D();//create an empty container 
    player.group.position.y=player.blocksize*height; 
    player.group.position.x=player.blocksize*width/2;     
    mesh = new THREE.Mesh( geometry, material1 );
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    player.group.add(mesh);
	
    mesh = new THREE.Mesh( geometry, material1 );
    mesh.position.x+=player.blocksize;
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    player.group.add(mesh);

    mesh = new THREE.Mesh( geometry, material1 );
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    mesh.position.x+=player.blocksize;
    mesh.position.y-=player.blocksize;
    player.group.add(mesh);

    mesh = new THREE.Mesh( geometry, material1 );
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    mesh.position.y-=player.blocksize;
    player.group.add(mesh);

    scene.add( player.group );//when done, add the group to the scene
    scene.add(inactiveBlocks);
    randomColours();

    renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize( window.innerWidth, window.innerHeight );

    //lights
    var lights = [];
	lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
	lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
	lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
	lights[ 3 ] = new THREE.PointLight( 0xffffff, 1, 0 );

	var lil=400;
	var big=800;
	lights[ 0 ].position.set( 0, width, 0 );
	lights[ 1 ].position.set( lil, big, lil );
	lights[ 2 ].position.set( - lil, lil, big );
	lights[ 3 ].position.set( lil, - big, - lil );

	scene.add( lights[ 0 ] );
	// scene.add( lights[ 1 ] );
	scene.add( lights[ 2 ] );
	scene.add( lights[ 3 ] );

	debugtext = document.createElement('div');
	debugtext.style.position = 'absolute';
	//debugtext.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
	debugtext.style.width = 32;
	debugtext.style.height = 32;
	debugtext.style.color="white";
	// debugtext.style.backgroundColor = "blue";
	debugtext.innerHTML = "hi there!";
	debugtext.style.top = 32 + 'px';
	debugtext.style.left = 32 + 'px';
	document.body.appendChild(debugtext);	  
    document.body.appendChild( renderer.domElement );

}

function randomColours(){	
	for (var i = 0; i < player.group.children.length; i++) {
		if(Math.random()*2>=1.0)
			player.group.children[i].material=material1;
		else
			player.group.children[i].material=material2;
	}
}
function resetBlock(){
	debugtext.innerHTML =  debugtext.innerHTML + "HIT!!!";
	inactiveBlocks.add(player.group.clone());
	player.group.position.y=player.blocksize*height;
	player.group.position.x=player.blocksize*width/2;  

	//Check if player spawn on an existing block. GAME OVER Scenaripo
	var mess = inactiveBlocks.children;
	for (var i = 0; i < mess.length; i++) {
		// if(mess[i].position.x == player.group.position.x)
		var xdif=mess[i].position.x - player.group.position.x;
		var ydif=mess[i].position.y - player.group.position.y;
		if(xdif<player.blocksize*2 && xdif>-player.blocksize*2 && ydif<player.blocksize*2.1 && ydif>-player.blocksize*2.1 ){//hit
			//GAME OVER - TODO
			// init();
		}
	}

	randomColours()
}

function handleInput(){	
	if (player.lockcount == 0){
		if (keys[40]){//DOWN arrow, force in update function
			player.forcedrop=true;
			player.lockcount=5;
		}
		if (keys[37] && player.group.position.x/player.blocksize >0){	//Left arrow
			console.log(" Left player.x = " +player.x);
			
			//Hit detection left
			var hit = false;
			var mess = inactiveBlocks.children;
			for (var i = 0; i < mess.length; i++) {
				var xdif=mess[i].position.x - player.group.position.x +1;
				var ydif=mess[i].position.y - player.group.position.y;				
				if(xdif<player.blocksize*2 && xdif>-player.blocksize*2 && ydif<player.blocksize*2.1 && ydif>-player.blocksize*2.1 ){
					hit=true;
				}
			}
			if(!hit){
				player.group.position.x-=player.blocksize;
				player.lockcount=5;
			}

		}
		if (keys[39] && player.group.position.x/player.blocksize <16){	//Right arrow
			console.log("Right player.x = " +player.x);
			//Hit detection
			var hit = false;
			var mess = inactiveBlocks.children;
			for (var i = 0; i < mess.length; i++) {
				var xdif=mess[i].position.x - player.group.position.x -1;
				var ydif=mess[i].position.y - player.group.position.y;				
				if(xdif<player.blocksize*2 && xdif>-player.blocksize*2 && ydif<player.blocksize*2.1 && ydif>-player.blocksize*2.1 ){
					hit=true;
				}
			}
			if(!hit){
				player.group.position.x+=player.blocksize;
				player.lockcount=5;
			}

		}
	}
	if (player.lockcount > 0)
		player.lockcount--;

	if (player.spincount == 0){
		if(keys[65] || keys[81] || keys[90]){//Q A Z			
			player.group.rotation.z+=Math.PI / 2;;		
			player.spincount=15;			
		}
		if(keys[83] || keys[87] ||keys[88]){// W S X
			player.group.rotation.z-=Math.PI / 2;;		
			player.spincount=15;			
		}
	}
	if (player.spincount > 0)
		player.spincount--;
	debugtext.innerHTML = "x: " +  player.group.position.x/player.blocksize + "  y:" + player.group.position.y/player.blocksize;

}

function updateGame(){
	// mesh.rotation.x += 0.01;
	//Handle Input First
	handleInput()

	dropcounter++;
	if(dropcounter>dropspeed || player.forcedrop){
		if(player.forcedrop)
			player.forcedrop=false;
		player.group.position.y-=player.blocksize;
		dropcounter=0;

		//Hit detection main block
		var mess = inactiveBlocks.children;
		for (var i = 0; i < mess.length; i++) {
			var xdif=mess[i].position.x - player.group.position.x;
			var ydif=mess[i].position.y - player.group.position.y;
			if(xdif<player.blocksize*2 && xdif>-player.blocksize*2 && ydif<player.blocksize*2.1 && ydif>-player.blocksize*2.1 ){
				resetBlock();
			}
		}
		if(player.group.position.y/player.blocksize<=0){ //bottom
			resetBlock();
		}
	}

}

function animate() {

    requestAnimationFrame( animate );

    updateGame()
    
    renderer.render( scene, camera );

}



		</script>

	</body>
</html>
