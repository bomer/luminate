
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.min.js"></script>

		<script>

var scene, camera, renderer;
var geometry, material, mesh;
var inactiveBlocks;// = []; //16 wide by 10 height as on PSP
var player = {};
var width=16;
var height=10;
var debugtext;
var dropspeed=15;
var dropcounter=0;


var keys = []; //Key Binding
window.onkeyup = function(e) {keys[e.keyCode]=false; player.movelock=false; player.spinlock=false;}
window.onkeydown = function(e) {keys[e.keyCode]=true; console.log('key down ' + e.keyCode);}

init();
animate();

function init() {

	//player.init
	player.blocksize=window.innerWidth / width;
	player.lockcount=0;
	//Camera
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 1000;
    camera.position.x = 8 * player.blocksize * 1.1;
    // camera.position.z = 1000;


    geometry = new THREE.BoxGeometry( player.blocksize, player.blocksize, player.blocksize );
    material = new THREE.MeshPhongMaterial( { color: 0xff0000, wireframe: false } );

    
    // player.y=2;
    //Empty blocks
    inactiveBlocks = new THREE.Object3D();

    //setup player block 
    player.group = new THREE.Object3D();//create an empty container 
    player.group.position.y=player.blocksize*3   
    mesh = new THREE.Mesh( geometry, material );
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    player.group.add(mesh);
	
    mesh = new THREE.Mesh( geometry, material );
    mesh.position.x+=player.blocksize * 1.1;
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    player.group.add(mesh);

    mesh = new THREE.Mesh( geometry, material );
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    mesh.position.x+=player.blocksize * 1.1;
    mesh.position.y-=player.blocksize * 1.1;
    player.group.add(mesh);

    mesh = new THREE.Mesh( geometry, material );
    mesh.position.x-=player.blocksize/2;
    mesh.position.y+=player.blocksize/2;
    mesh.position.y-=player.blocksize * 1.1;
    player.group.add(mesh);

    scene.add( player.group );//when done, add the group to the scene
    scene.add(inactiveBlocks);


    renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize( window.innerWidth, window.innerHeight );

    //lights
    var lights = [];
	lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
	lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
	lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
	lights[ 3 ] = new THREE.PointLight( 0xffffff, 1, 0 );


	lights[ 0 ].position.set( 0, 200, 0 );
	lights[ 1 ].position.set( 100, 200, 100 );
	lights[ 2 ].position.set( - 100, 100, 200 );
	lights[ 3 ].position.set( 100, - 200, - 100 );

	scene.add( lights[ 0 ] );
	// scene.add( lights[ 1 ] );
	scene.add( lights[ 2 ] );
	scene.add( lights[ 3 ] );

	debugtext = document.createElement('div');
	debugtext.style.position = 'absolute';
	//debugtext.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
	debugtext.style.width = 32;
	debugtext.style.height = 32;
	debugtext.style.color="white";
	// debugtext.style.backgroundColor = "blue";
	debugtext.innerHTML = "hi there!";
	debugtext.style.top = 32 + 'px';
	debugtext.style.left = 32 + 'px';
	document.body.appendChild(debugtext);	  

    document.body.appendChild( renderer.domElement );

}

function handleInput(){
	// console.log('input');
	if (player.lockcount == 0){
		if (keys[37] && player.group.position.x/player.blocksize >-9){	//Left arrow
			console.log(" Left player.x = " +player.x);
			player.group.position.x-=player.blocksize*1.1;
			player.lockcount=5;
		}
		if (keys[39] && player.group.position.x/player.blocksize <9){	//Right arrow
			console.log("Right player.x = " +player.x);
			player.group.position.x+=player.blocksize * 1.1;
			player.lockcount=5;
		}
	}
	if (player.lockcount > 0)
		player.lockcount--;
	debugtext.innerHTML = "x: " +  player.group.position.x/player.blocksize + "  y:" + player.group.position.y/player.blocksize;

}

function updateGame(){
	// mesh.rotation.x += 0.01;
	//Handle Input First
	handleInput()

	dropcounter++;
	if(dropcounter>dropspeed){
		player.group.position.y-=player.blocksize * 1.1;
		dropcounter=0;

		//Hit detection main block
		var mess = inactiveBlocks.children;
		for (var i = 0; i < mess.length; i++) {
			var xdif=mess[i].position.x - player.group.position.x;
			var ydif=mess[i].position.y - player.group.position.y;
			if(xdif<player.blocksize*2.2 && xdif>-player.blocksize*2.2 && ydif<player.blocksize*2.2 && ydif>-player.blocksize*2.2 ){
				debugtext.innerHTML =  debugtext.innerHTML + "HIT!!!";
				inactiveBlocks.add(player.group.clone());
				player.group.position.y=player.blocksize*3;

			}
		}

		if(player.group.position.y/player.blocksize<=-4){ //bottom
			inactiveBlocks.add(player.group.clone());
			player.group.position.y=player.blocksize*3;

		}
	}

}

function animate() {

    requestAnimationFrame( animate );

    updateGame()
    
    renderer.render( scene, camera );

}



		</script>

	</body>
</html>
